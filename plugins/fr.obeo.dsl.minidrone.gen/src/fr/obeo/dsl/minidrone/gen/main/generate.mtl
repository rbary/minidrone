[*******************************************************************************
 * Copyright (c) 2016 Obeo.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Obeo - initial API and implementation
 *******************************************************************************/]

[**
 * The documentation of the module generate.
 */]
[module generate('http://www.obeo.fr/dsl/minidrone/1.0.0')]


[**
 * The documentation of the template genElement.
 * @param minidroneProgram
 */]
[template public genElement(minidroneProgram : MiniDroneProgram)]
[comment @main/]
[file ('main.c', false, 'UTF-8')]
/**
 * Copyright (c) 2016 Obeo.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * 	Obeo - initial API and implementation
 *
 */

/*****************************************
 *
 *             include
 *
 *****************************************/

#include "JSPilotingMinimalCommands.h"


/*****************************************
 *
 *             private implementation
 *
 *****************************************/

void stateChanged (eARCONTROLLER_DEVICE_STATE newState, eARCONTROLLER_ERROR error, void *customData)
{
	ARSAL_PRINT(ARSAL_PRINT_INFO, TAG_MAIN, "    - stateChanged newState: %d .....", newState);

	switch (newState)
	{
		case ARCONTROLLER_DEVICE_STATE_STOPPED:
			ARSAL_Sem_Post (&(stateSem));
			//run = 0;
			break;

		case ARCONTROLLER_DEVICE_STATE_RUNNING:
			ARSAL_Sem_Post (&(stateSem));
			break;

		default:
			break;
	}
}

void commandReceived (eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_ELEMENT_t *elementDictionary, void *customData)
{
	ARCONTROLLER_Device_t *deviceController = customData;

	if (deviceController != NULL)
	{
		// if the command received is a battery state changed
		if (commandKey == ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED)
		{
			ARCONTROLLER_DICTIONARY_ARG_t *arg = NULL;
			ARCONTROLLER_DICTIONARY_ELEMENT_t *singleElement = NULL;

			if (elementDictionary != NULL)
			{
				// get the command received in the device controller
				HASH_FIND_STR (elementDictionary, ARCONTROLLER_DICTIONARY_SINGLE_KEY, singleElement);

				if (singleElement != NULL)
				{
					// get the value
					HASH_FIND_STR (singleElement->arguments, ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT, arg);

					if (arg != NULL)
					{
						ARSAL_PRINT(ARSAL_PRINT_INFO, TAG_MAIN, "command received :%d",arg->value.U8);
					}
					else
					{
						ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_MAIN, "arg is NULL");
					}
				}
				else
				{
					ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_MAIN, "singleElement is NULL");
				}
			}
			else
			{
				ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_MAIN, "elements is NULL");
			}
		}
	}
}

/*****************************************
 *
 *             main implementation
 *
 *****************************************/
int main(int argc, char **argv) {
	//local declarations
	int error = 0;
    ARSAL_Sem_Init (&(stateSem), 0, 0);
    eARCONTROLLER_DEVICE_STATE deviceState = ARCONTROLLER_DEVICE_STATE_MAX;
    ARDISCOVERY_Device_t *discoveryDevice = NULL;
    ARCONTROLLER_Device_t *deviceController = NULL;


    /*****************************************
     *
     *   		Initialization
     *
     *****************************************/

    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG_MAIN, "-- [minidroneProgram.name/] --");

    // Create new discovery device
    if(!error){
    	discoveryDevice = createInitDiscoveryDevice();
    	if(discoveryDevice == NULL){error = 1;}
    }

    // Create new device controller
    if(!error){
    	deviceController = createDeviceController(discoveryDevice);
    	if(discoveryDevice == NULL){error = 1;}
    }



    if(!error){
    	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
    	errorController = ARCONTROLLER_Device_AddStateChangedCallback (deviceController, stateChanged, deviceController);

		if (errorController != ARCONTROLLER_OK)
		{
			ARSAL_PRINT (ARSAL_PRINT_ERROR, TAG_MAIN, "add State callback failed.");
			error = 1;
		}
    }

    if(!error)
    {
       	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
       	errorController = ARCONTROLLER_Device_AddCommandReceivedCallback(deviceController, commandReceived, deviceController);

   		if (errorController != ARCONTROLLER_OK)
   		{
   			ARSAL_PRINT (ARSAL_PRINT_ERROR, TAG_MAIN, "add State callback failed.");
   			error = 1;
   		}
    }

    if(!error){
    	error = startDeviceController(deviceController);
    }

	sleep(1);

    /*****************************************
     *
     *			Piloting
     *
     *****************************************/
[for (it : Instruction | minidroneProgram.instructions) separator('\n')]
	[if (it.oclIsTypeOf(Go))]	
		// Send go command
		if(!error)
		{
			error = sendGoCommand(deviceController, [it.oclAsType(Go).distance/]);
		}
	[/if]
	[if (it.oclIsTypeOf(Turn))]
		// Send turn command
		if(!error)
		{
			error = sendTurnCommand(deviceController, [it.oclAsType(Turn).angle/]);
		}
	[/if]
	[if (it.oclIsTypeOf(Jump))]
		//Send jump command
		if(!error)
		{
			error = sendJumpCommand(deviceController, [it.oclAsType(Jump).jumpType/]);
		}
	[/if]
[/for]

    /*****************************************
     *
     *			End
     *
     *****************************************/
    stopDeviceController(deviceController);
    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG_MAIN, "-- END --");
    return EXIT_SUCCESS;
}
[/file]
[/template]

[**
 * The documentation of the template genMakefile.
 * @param minidroneProgram
 */]
[template public genMakefile(minidroneProgram : MiniDroneProgram)]
[comment @main/]
[file ('Makefile', false, 'UTF-8')]
#
# Copyright (c) 2016 Obeo.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
# Obeo - initial API and implementation
#

EXEC_NAME=[minidroneProgram.name/]

SDK_DIR=../../ARDroneSDK_Unix

IDIR=./
CFLAGS=-I$(IDIR) -I$(SDK_DIR)/include

OBJDIR=obj
LDIR = $(SDK_DIR)/lib

EXTERNAL_LIB=-lncurses

LIBS=-L$(LDIR) -larsal -larcontroller-3.1.0 -lardiscovery-3.1.0 $(EXTERNAL_LIB) -Wl,-rpath=$(LDIR)
LIBS_DBG=-L$(LDIR) -larsal_dbg -larcontroller_dbg -lardiscovery_dbg $(EXTERNAL_LIB) -Wl,-rpath=$(LDIR)

_DEPS = JSPilotingMinimalCommands.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = JSPilotingMinimalCommands.o main.o
OBJ = $(patsubst %,$(OBJDIR)/%,$(_OBJ))

$(OBJDIR)/%.o: %.c $(DEPS)
	@ ['['/] -d $(OBJDIR) [']'/] || mkdir $(OBJDIR)
	@ $(CC) -c -o $@ $< $(CFLAGS)

$(EXEC_NAME): $(OBJ)
	$(CC) -o $@ $^ $(CFLAGS) $(LIBS)

.PHONY: clean

clean:
	@ rm -f $(OBJDIR)/*.o *~ core $(INCDIR)/*~
	@ rm -rf $(OBJDIR)
	@ rm -r $(EXEC_NAME)

run:
	LD_LIBRARY_PATH=$(LDIR) ./$(EXEC_NAME)
[/file]
[/template]

[**
 * The documentation of the template genHeader.
 * @param minidroneProgram
 */]
[template public genHeader(minidroneProgram : MiniDroneProgram)]
[comment @main /]
[file ('JSPilotingMinimalCommands.h', false, 'UTF-8')]
/**
 * Copyright (c) 2016 Obeo.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * 	Obeo - initial API and implementation
 *
 */

#ifndef JSPILOTINGMINIMALCOMMANDS_H_
#define JSPILOTINGMINIMALCOMMANDS_H_

/*****************************************
 *
 *             include
 *
 *****************************************/
#include <stdlib.h>
#include <curses.h>
#include <string.h>
#include <unistd.h>

#include <../../ARDroneSDK_Unix/include/libARSAL/ARSAL.h>
#include <../../ARDroneSDK_Unix/include/libARController/ARController.h>
#include <../../ARDroneSDK_Unix/include/libARDiscovery/ARDiscovery.h>

/*****************************************
 *
 *             define :
 *
 *****************************************/
#define TAG_JS_CMD "JSPilotingMinCommands"
#define TAG_MAIN "Main"
#define JS_IP_ADDRESS "192.168.2.1"
#define JS_DISCOVERY_PORT 44444

#define VELOCITY_PERCENT 50
#define ANGLE_MAX 360
#define JUMP_LONG 0
#define JUMP_HIGH 1
#define JUMP_MAX 2
ARSAL_Sem_t stateSem;

// called to create and init a discovery device; implies a JS discovery device creation with Wifi init
ARDISCOVERY_Device_t * createInitDiscoveryDevice();

// called to create a device controller
ARCONTROLLER_Device_t * createDeviceController(ARDISCOVERY_Device_t *discoveryDevice);

// called to add a state change callback to a device controller to be notified when the device controller starts, stops
int addStateChangeCallbackToDeviceController(ARCONTROLLER_Device_t *deviceController, ARCONTROLLER_Device_StateChangedCallback_t *stateChangedCallback);

// called to add a command reception callback to a device controller to be notified when a command has been received from JS
int addCommandReceivedCallbackToDeviceController(ARCONTROLLER_Device_t *deviceController, ARCONTROLLER_DICTIONARY_CALLBACK_t commandReceivedCallback);

// called to start the device controller implies a wifi connection between our system (Unix laptop) and the JS as result
int startDeviceController(ARCONTROLLER_Device_t *deviceController);

// called to stop the device controller implies a wifi disconnection between our system(Unix laptop) and the JS as result
void stopDeviceController(ARCONTROLLER_Device_t *deviceController);

// called to get the state of the JS
eARCONTROLLER_DEVICE_STATE getDeviceState(ARCONTROLLER_Device_t *deviceController,ARSAL_Sem_t stateSem, eARCONTROLLER_DEVICE_STATE deviceState );

// called when a command has been received from the drone
//void commandReceived (eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_ELEMENT_t *elementDictionary, void *customData);

// called when the state of the device controller has changed
//void stateChanged (eARCONTROLLER_DEVICE_STATE newState, eARCONTROLLER_ERROR error, void *customData,ARSAL_Sem_t stateSem);

// called to send a jump command to the JS
int sendJumpCommand(ARCONTROLLER_Device_t *deviceController,int jumpType);

// called to send a Go command to the JS
int sendGoCommand(ARCONTROLLER_Device_t *deviceController,int distance);

// called to send turn command to the JS
int sendTurnCommand(ARCONTROLLER_Device_t *deviceController,int angle);

// called to compute the microsecond sleep when we send command to make straight the minidrone
useconds_t computeStraightUsleep(int distance,int velocityPercent);

// called to compute the roll angle percent
int computeAnglePercent(int angle);

#endif /* JSPILOTINGMINIMALCOMMANDS_H_ */

[/file]
[/template]

[**
 * The documentation of the template genSource.
 * @param minidroneProgram
 */]
[template public genSource(minidroneProgram : MiniDroneProgram)]
[comment @main /]
[file ('JSPilotingMinimalCommands.c', false, 'UTF-8')]
	/**
 * Copyright (c) 2016 Obeo.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * 	Obeo - initial API and implementation
 *
 */

/*****************************************
 *
 *             include
 *
 *****************************************/
#include "JSPilotingMinimalCommands.h"


/*****************************************
 *
 *             private implementation
 *
 ****************************************/

ARDISCOVERY_Device_t * createInitDiscoveryDevice()
{
	eARDISCOVERY_ERROR errorDiscovery = ARDISCOVERY_OK;
	ARDISCOVERY_Device_t *discoveryDevice = NULL;

	discoveryDevice = ARDISCOVERY_Device_New(&errorDiscovery);

	if(errorDiscovery == ARDISCOVERY_OK)
	{
		//create a specific JS discovery device
		errorDiscovery = ARDISCOVERY_Device_InitWifi(discoveryDevice, ARDISCOVERY_PRODUCT_JS,"JS",JS_IP_ADDRESS,JS_DISCOVERY_PORT);

		if(errorDiscovery != ARDISCOVERY_OK)
		{
            ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD, "Discovery error :%s", ARDISCOVERY_Error_ToString(errorDiscovery));
			return NULL;
		}
	}
	else
	{
		 ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD, "Discovery error :%s", ARDISCOVERY_Error_ToString(errorDiscovery));
		 return NULL;
	}

	ARSAL_PRINT (ARSAL_PRINT_INFO, TAG_JS_CMD, "Creation of discovery device succeeded");
	return discoveryDevice;
}

ARCONTROLLER_Device_t * createDeviceController(ARDISCOVERY_Device_t *discoveryDevice)
{
    eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
    ARCONTROLLER_Device_t *deviceController = NULL;

    deviceController = ARCONTROLLER_Device_New (discoveryDevice, &errorController);

    if(errorController != ARCONTROLLER_OK)
    {
        ARSAL_PRINT (ARSAL_PRINT_ERROR, TAG_JS_CMD, "Creation of device controller failed.");
    	return NULL;
    }
    ARSAL_PRINT (ARSAL_PRINT_INFO, TAG_JS_CMD, "Creation of device controller succeeded.");
    ARDISCOVERY_Device_Delete(&discoveryDevice);
    return deviceController;
}



int startDeviceController(ARCONTROLLER_Device_t *deviceController)
{
	int failed = 0;
	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG_JS_CMD, "Start device controller and try connecting...");
	errorController = ARCONTROLLER_Device_Start(deviceController);

	if(errorController != ARCONTROLLER_OK)
	{
        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD, " start device controller failed ...");
        failed = 1;
	}
	return failed;
}

void stopDeviceController(ARCONTROLLER_Device_t *deviceController)
{
	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG_JS_CMD, "disconnecting ...");
	errorController = ARCONTROLLER_Device_Start(deviceController);

	if(errorController != ARCONTROLLER_OK)
	{
		ARSAL_PRINT (ARSAL_PRINT_ERROR, TAG_JS_CMD, "add callback failed.");
	}
}

eARCONTROLLER_DEVICE_STATE getDeviceState(ARCONTROLLER_Device_t *deviceController,ARSAL_Sem_t stateSem, eARCONTROLLER_DEVICE_STATE deviceState )
{
	// wait state update update
	ARSAL_Sem_Wait (&(stateSem));

	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
	deviceState = ARCONTROLLER_Device_GetState(deviceController,&errorController);

	if ((errorController != ARCONTROLLER_OK) || (deviceState != ARCONTROLLER_DEVICE_STATE_RUNNING))
	{
		ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD, "- deviceState :%d", deviceState);
		ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD, "- error :%s", ARCONTROLLER_Error_ToString(errorController));
	}
	return deviceState;
}

int sendJumpCommand(ARCONTROLLER_Device_t *deviceController,int jumpType)
{
	int failed = 0;
	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;

	switch (jumpType) {
		case JUMP_HIGH:
			errorController = deviceController->jumpingSumo->sendAnimationsJump (deviceController->jumpingSumo,ARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE_HIGH);
			break;
		case JUMP_LONG:
			errorController = deviceController->jumpingSumo->sendAnimationsJump (deviceController->jumpingSumo,ARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE_LONG);
			break;
		case JUMP_MAX:
			errorController = deviceController->jumpingSumo->sendAnimationsJump (deviceController->jumpingSumo,ARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE_MAX);
			break;
		default:
			break;
	}

	if(errorController != ARCONTROLLER_OK){
		ARSAL_PRINT (ARSAL_PRINT_ERROR, TAG_JS_CMD, "send jump command failed ...");
		failed = 1;
	}
	return failed;
}

int sendGoCommand(ARCONTROLLER_Device_t *deviceController, int distance) {
	int failed = 0;

	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
	errorController = deviceController->jumpingSumo->setPilotingPCMDFlag(
			deviceController->jumpingSumo, 1);
	errorController = deviceController->jumpingSumo->setPilotingPCMDSpeed(
			deviceController->jumpingSumo, VELOCITY_PERCENT);
	usleep(computeStraightUsleep(abs(distance), VELOCITY_PERCENT));

	if (errorController != ARCONTROLLER_OK) {
		ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD,
				"send go command failed ...");
		failed = 1;
	}
	return failed;
}

int sendTurnCommand(ARCONTROLLER_Device_t *deviceController, int angle) {
	int failed = 0;
	eARCONTROLLER_ERROR errorController = ARCONTROLLER_OK;
	errorController = deviceController->jumpingSumo->setPilotingPCMDFlag(
			deviceController->jumpingSumo, 1);
	errorController = deviceController->jumpingSumo->setPilotingPCMDTurn(
			deviceController->jumpingSumo, computeAnglePercent(angle));
	usleep(50000);

	if (errorController != ARCONTROLLER_OK) {
		ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG_JS_CMD, "send turn command failed");
		failed = 1;
	}
	return failed;
}

useconds_t computeStraightUsleep(int distance, int velocityPercent) {
	useconds_t cmd_usleep;

	switch (velocityPercent) {
	case 10:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 20:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 30:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 40:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 50:
		cmd_usleep = distance * 735000 + distance * 130000;
		break;
	case 60:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 70:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 80:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 90:
		cmd_usleep = 1000000; // equal to 1s to adjust
		break;
	case 100:
		cmd_usleep = distance * 480000; // to adjust too
		break;
	default:
		break;
	}
	return cmd_usleep;
}

int computeAnglePercent(int angle) {
	int angle_percent;
	angle_percent = (100 * angle) / ANGLE_MAX;
	return angle_percent;
}
[/file]
[/template]


